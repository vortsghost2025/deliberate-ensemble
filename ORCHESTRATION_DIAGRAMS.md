# Orchestration Topology - Visual Diagrams

## 1. Directory Tree Structure

```
workspace/
│
├── agents/                          [CORE MULTI-AGENT SYSTEM]
│   ├── __init__.py                 [Exports all agents]
│   ├── base_agent.py               [ABC/Interface - BaseAgent class]
│   │   └── Defines: BaseAgent, AgentStatus enum
│   │       Methods: __init__, execute(), create_message(), 
│   │               validate_input(), get_status_report()
│   │
│   ├── orchestrator.py             [MAIN CONDUCTOR]
│   │   └── Class: OrchestratorAgent(BaseAgent)
│   │       Manages: Workflow state, agent registry, handoffs
│   │       States: IDLE, FETCHING_DATA, ANALYZING_MARKET, 
│   │               BACKTESTING, RISK_ASSESSMENT, EXECUTING, 
│   │               MONITORING, ERROR, PAUSED
│   │
│   ├── data_fetcher.py             [Agent 1 - Data Acquisition]
│   │   └── Class: DataFetchingAgent(BaseAgent)
│   │       Method: execute(symbols) → market_data
│   │       APIs: CoinGecko (free)
│   │       Features: 5-min cache, API error handling
│   │
│   ├── market_analyzer.py          [Agent 2 - Analysis + Safety]
│   │   └── Class: MarketAnalysisAgent(BaseAgent)
│   │       Method: execute(market_data) → analysis + regime
│   │       Analysis: RSI, MACD, trend, volatility
│   │       SAFETY: Detects bearish → downtrend_detected flag
│   │
│   ├── backtester.py               [Agent 3 - Validation]
│   │   └── Class: BacktestingAgent(BaseAgent)
│   │       Method: execute(market_data, analysis) → win_rate
│   │       Purpose: Validate signals against history
│   │
│   ├── risk_manager.py             [Agent 4 - Safety + Sizing]
│   │   └── Class: RiskManagementAgent(BaseAgent)
│   │       Method: execute(market_data, analysis, backtest) → position_size
│   │       SAFETY: Enforces 1% risk max per trade
│   │       Calculates: SL, TP, position sizing
│   │
│   ├── executor.py                 [Agent 5 - Execution]
│   │   └── Class: ExecutionAgent(BaseAgent)
│   │       Method: execute(position_data) → trade_executed
│   │       Mode: Paper trading by default
│   │       Tracks: Open positions, P&L, performance
│   │
│   └── monitor.py                  [Agent 6 - Logging]
│       └── Class: MonitoringAgent(BaseAgent)
│           Method: execute(all_results) → logs + alerts
│           Output: logs/trading_bot.log, logs/events.jsonl
│
├── logs/                           [Generated by Monitor Agent]
│   ├── trading_bot.log            [Text logs]
│   └── events.jsonl               [JSON structured events]
│
├── data/                          [Future: Historical data]
├── tests/                         [Future: Additional tests]
├── utils/                         [Future: Utilities]
│
└── main.py                        [Entry point - initializes and runs orchestrator]
```

---

## 2. Agent Class Hierarchy

```
                    object
                      │
              ┌───────┴───────┐
              │               │
         Enum (status)    BaseAgent
         (IDLE, WORKING,       │
          ERROR, PAUSED)       │
                           ┌───┴────────────────────┬─────────────────┬──────────────┐
                           │                        │                 │              │
                    OrchestratorAgent       DataFetchingAgent  MarketAnalysisAgent  RiskManagementAgent
                    (Main Conductor)       (Data Acquisition)  (Analysis + Safety)  (Sizing + Safety)
                           │
                   Inherits from BaseAgent
                   Manages WorkflowStage(enum)
                   Registry of sub-agents
                           
                           │
              ┌────────────┼────────────┐
              │            │            │
        BacktestingAgent ExecutionAgent MonitoringAgent
        (Validation)      (Trading)     (Logging)
```

---

## 3. Main Orchestrator Workflow - State Machine

```
                    START
                      ↓
            ┌─────────────────────┐
            │   Check if trading  │
            │     is allowed      │
            │  (circuit breaker,  │
            │  pause status)      │
            └────────┬────────────┘
                     │
        ┌────────────┴────────────┐
        │ YES (trading allowed)   │ NO → RETURN FAIL
        ↓                         └──────────────→ END
        
    WORKFLOW STAGE: IDLE → FETCHING_DATA
        ↓
    ┌──────────────────────────────────────┐
    │  [1] DataFetchingAgent.execute()     │
    │      Input: {symbols: [...]}        │
    │      Output: {market_data: {...}}   │
    └────────────┬─────────────────────────┘
                 ↓
    WORKFLOW STAGE: ANALYZING_MARKET
        ↓
    ┌──────────────────────────────────────┐
    │  [2] MarketAnalysisAgent.execute()   │
    │      Input: {market_data: {...}}    │
    │      Output: {analysis: {...},      │
    │               regime: "bullish|..."}│
    │               downtrend_detected}   │
    └────────────┬─────────────────────────┘
                 │
        ┌────────┴──────────┐
        │ downtrend_        │
        │ detected = TRUE?  │ YES → pause_trading()
        │                   └─────→ PAUSED state → END
        │ NO
        ↓
    WORKFLOW STAGE: BACKTESTING
        ↓
    ┌──────────────────────────────────────┐
    │  [3] BacktestingAgent.execute()      │
    │      Input: {market_data, analysis}  │
    │      Output: {backtest_results,      │
    │               win_rate: 0.55}        │
    └────────────┬─────────────────────────┘
                 ↓
    WORKFLOW STAGE: RISK_ASSESSMENT
        ↓
    ┌──────────────────────────────────────┐
    │  [4] RiskManagementAgent.execute()   │
    │      Input: {market_data, analysis,  │
    │              backtest_results}       │
    │      Output: {position_approved,     │
    │               position_size: 0.05,   │
    │               stop_loss, take_profit}│
    └────────────┬─────────────────────────┘
                 │
        ┌────────┴──────────────┐
        │ position_approved?    │
        │ risk > 1%? → NO       │ YES (risk > 1%) → REJECTED
        │                       └──────────→ END
        │ YES
        ↓
    WORKFLOW STAGE: EXECUTING
        ↓
    ┌──────────────────────────────────────┐
    │  [5] ExecutionAgent.execute()        │
    │      Input: {position_size, SL, TP}  │
    │      Output: {trade_executed: True,  │
    │               trade_id: 1}           │
    └────────────┬─────────────────────────┘
                 ↓
    WORKFLOW STAGE: MONITORING
        ↓
    ┌──────────────────────────────────────┐
    │  [6] MonitoringAgent.execute()       │
    │      Input: {all workflow results}   │
    │      Output: {events_logged: 1,      │
    │               alerts: [...]}         │
    │      Side-effect: Write logs         │
    └────────────┬─────────────────────────┘
                 ↓
    WORKFLOW STAGE: IDLE
        ↓
     SUCCESS → END / REPEAT
```

---

## 4. Agent Handoff Flow with Message Format

```
┌─────────────────────────────────────────────────────────────────┐
│                    ORCHESTRATOR (Conductor)                     │
│                                                                 │
│  orchestrator.execute(symbols=['SOL/USDT', 'BTC/USDT'])        │
└────────────────────────────┬──────────────────────────────────┘
                             │
                    ┌────────┴─────────┐
                    │ Creates list of  │
                    │ agent phases to  │
                    │ execute          │
                    └────────┬─────────┘
                             │
        ┌────────────────────┴────────────────────┐
        │                                         │
    Phase 1                                  Phase 2
    DataFetcher                           Analyzer
        │                                     │
        │ orchestrator._execute_agent_phase()
        │ agent_name: 'DataFetchingAgent'
        │ action: 'fetch_data'
        │ input_data: {symbols: [...]}
        │                                     │
    ┌───▼──────────────────────────────────┐  │
    │ agent.execute(input_data)            │  │
    │ → fetch from CoinGecko API           │  │
    │ → normalize data                     │  │
    │ → create_message(action, data)       │  │
    │ → return: {                          │  │
    │     agent: 'DataFetchingAgent',     │  │
    │     action: 'fetch_data',           │  │
    │     timestamp: '...',               │  │
    │     success: True,                  │  │
    │     data: {market_data: {...}},    │  │
    │     error: None                     │  │
    │   }                                 │  │
    └───┬──────────────────────────────────┘  │
        │                                     │
    Result returned                      ┌────▼──────────────────────────┐
    to orchestrator                      │ agent.execute(input_data)      │
        │                                │ input_data: {market_data: {...}}
        │                                │ → calculate RSI, MACD          │
        │                                │ → detect downtrend             │
        │                                │ → classify regime              │
        │                                │ → create_message(action, data) │
        │                                │ → return: {                    │
        │                                │     agent: 'MarketAnalyzer',  │
        │                                │     action: 'analyze_market',  │
        │                                │     timestamp: '...',         │
        │                                │     success: True,             │
        │                                │     data: {                    │
        │                                │       analysis: {...},        │
        │                                │       regime: 'bullish',      │
        │                                │       downtrend_detected: False
        │                                │     },                         │
        │                                │     error: None               │
        │                                │   }                            │
        │                                └────┬──────────────────────────┘
        │                                     │
        │ Orchestrator checks:                │
        │ "downtrend_detected?"               │
        │ NO → continue                       │
        │                                     │
        ├────────────────────────────────────►│
        │ Pass market_data + analysis to      │
        │ next phases...                      │
        │
        └─────────────────────────────────────┘
```

---

## 5. Safety Layers in Orchestration

```
┌─────────────────────────────────────────────────────────────────┐
│                    SAFETY ARCHITECTURE                          │
└─────────────────────────────────────────────────────────────────┘

Layer 1: TRADING PAUSE CHECK (Orchestrator)
┌───────────────────────────────────────┐
│ is_trading_allowed()                  │
├───────────────────────────────────────┤
│ Check:                                │
│ • trading_paused flag                 │
│ • circuit_breaker_active              │
│ → if NO → block entire workflow       │
└───────────────────────────────────────┘
                    │
                    ▼
Layer 2: DOWNTREND DETECTION (Market Analyzer)
┌───────────────────────────────────────┐
│ MarketAnalysisAgent.execute()         │
├───────────────────────────────────────┤
│ If price_change < -5%:                │
│ • Set downtrend_detected = True       │
│ • Return bearish regime               │
│ → Orchestrator calls pause_trading()  │
│ → No more trades that day             │
└───────────────────────────────────────┘
                    │
                    ▼
Layer 3: 1% RISK ENFORCEMENT (Risk Manager)
┌───────────────────────────────────────┐
│ RiskManagementAgent.execute()         │
├───────────────────────────────────────┤
│ Calculate: risk_amount = position*SL% │
│ If risk_amount > (account * 0.01):    │
│ • Set position_approved = False       │
│ • Reject trade                        │
│ → Cannot be overridden in code        │
└───────────────────────────────────────┘
                    │
                    ▼
Layer 4: CIRCUIT BREAKER (Orchestrator)
┌───────────────────────────────────────┐
│ activate_circuit_breaker(reason)      │
├───────────────────────────────────────┤
│ On critical error:                    │
│ • circuit_breaker_active = True       │
│ • trading_paused = True               │
│ • Status = ERROR                      │
│ → Manual intervention required        │
│ → Prevents cascade failures           │
└───────────────────────────────────────┘
```

---

## 6. Data Flow Diagram - Complete Message Path

```
                    ORCHESTRATOR
                    (Main Conductor)
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
        ▼                  ▼                  ▼
    
    ┌─────────────┐  ┌──────────────┐  ┌─────────────┐
    │   Agent 1   │  │   Agent 2    │  │   Agent N   │
    │ DataFetcher │  │   Analyzer   │  │  [Others]   │
    └──────┬──────┘  └───────┬──────┘  └──────┬──────┘
           │                 │               │
           │ execute()       │ execute()    │ execute()
           │                 │               │
    ┌──────▼──────┐  ┌───────▼──────┐  ┌──────▼──────┐
    │ Processing  │  │ Processing   │  │ Processing  │
    │ • Fetch API │  │ • Calculate  │  │ • Action    │
    │ • Normalize │  │ • Analyze    │  │ • Specific  │
    │ • Validate  │  │ • Detect     │  │ • Logic     │
    └──────┬──────┘  └───────┬──────┘  └──────┬──────┘
           │                 │               │
           │ return          │ return       │ return
           │                 │               │
    ┌──────▼────────────────────────────────▼──────┐
    │  create_message(                             │
    │    agent: str,                              │
    │    action: str,                             │
    │    timestamp: str,                          │
    │    success: bool,                           │
    │    data: dict,                              │
    │    error: str|None                          │
    │  )                                          │
    └──────┬─────────────────────────────────────┘
           │
           ▼ return
           
    ┌─────────────────────────────────────────────┐
    │ Standard Message Format                     │
    │ {                                           │
    │   "agent": "AgentName",                    │
    │   "action": "what_it_did",                 │
    │   "timestamp": "2026-02-02T...",           │
    │   "success": True,                         │
    │   "data": {...},                           │
    │   "error": None                            │
    │ }                                           │
    └──────┬────────────────────────────────────┘
           │
           ▼ back to
           
    ORCHESTRATOR receives message
           │
    ┌──────▼──────────────┐
    │ Check result        │
    │ • success?          │
    │ • Next phase?       │
    │ • Safety checks?    │
    │ • Continue?         │
    └──────┬──────────────┘
           │
    ┌──────▼──────────────┐
    │ Route to next agent │
    │ OR                  │
    │ Stop workflow       │
    │ OR                  │
    │ Error recovery      │
    └────────────────────┘
```

---

## 7. Agent Registry (Orchestrator Coordination)

```
OrchestratorAgent.agent_registry
{
    "DataFetchingAgent": <DataFetchingAgent instance>,
    "MarketAnalysisAgent": <MarketAnalysisAgent instance>,
    "RiskManagementAgent": <RiskManagementAgent instance>,
    "BacktestingAgent": <BacktestingAgent instance>,
    "ExecutionAgent": <ExecutionAgent instance>,
    "MonitoringAgent": <MonitoringAgent instance>
}

When orchestrator needs to execute an agent:
    orchestrator._execute_agent_phase(
        agent_name='RiskManagementAgent',
        action='assess_and_size_position',
        input_data={...}
    )
    
    1. Lookup: registry['RiskManagementAgent'] ← Get instance
    2. Execute: agent.execute(input_data)
    3. Return: result message
    4. Handle: Check success/error
    5. Log: Record in workflow_history
```

---

## Summary Table: Orchestration Architecture

| Component | Type | Purpose | Key Method |
|-----------|------|---------|-----------|
| **BaseAgent** | ABC | Interface for all agents | `execute()` |
| **OrchestratorAgent** | Agent | Main conductor | `execute(symbols)` |
| **WorkflowStage** | Enum | State machine states | 9 states |
| **AgentStatus** | Enum | Agent status | 4 states |
| **agent_registry** | Dict | Store agents | `register_agent()` |
| **_execute_agent_phase()** | Method | Call agents | Handoff coordination |
| **Message Format** | Dict | Standardized output | `create_message()` |

✅ **Complete orchestration topology confirmed**
